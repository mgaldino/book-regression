[["checagem.html", "Capítulo 10 - Checagem 10.1 Resíduos 10.2 Modelo no R", " Capítulo 10 - Checagem Antes de proceder com a parte de inferência estatística, vamos apresentar como realizar checagem do modelo. A razão é que, em geral, a teoria de inferência depende da suposição do modelo ser correta. Então, faz sentido primeiro checar se o modelo satisfaz os pressupostos, e depois fazer inferência. Vamos então apresentar os principais testes e checagem que devemos fazer com nosso modelo de regressão linear. Aqui vale uma comentário sobre inferência Bayesiana, que não estamos utilizando em nosso curso, mas que eu particularmente utilizo em minha pesquisa aplicada. O prática de modelagem padrão na inferência Bayesiana é escrever formalmente uma verossimilhança (como fizemos com MLE) e estimar distribuições de porbabilidades para os parâmetros, e checar o modelo para ver se essas distribuições fazem sentido. Portanto, a checagem do modelo acontece automaticamente e de maneira integrada, ao contrário do que faremos aqui. Ou seja, recomendo que vocês aprendam a fazer inferência Bayesiana e prescindam de toda essa maquinaria que irei apresentar. 10.1 Resíduos Os resíduo para cada obsrrvação \\(i\\) é a diferença entre a previsão do modelo de regressão \\(\\hat{y_i}\\) e o valor observado \\(y_i\\), as vezes chamado de \\(\\hat{e}\\), para diferenciar do erro populacional, \\(e\\). No caso de nosso modelo de regressão linear com um único preditor, temos: \\[ \\hat{e_i} = y_i - (\\hat{\\alpha} + \\hat{\\beta} \\cdot x_i) \\] Eis algumas propriedade dos resíduos. 1. Os resíduos deveriam ter esperança zero, condicional aos preditores. Formalmente, \\(\\mathbb{E}[\\hat{e}|X=x] = 0\\) Se estivermos supondo homecedasticidade, devem ter variância constante (o que raramente será o caso). Os resíduos não podem ser completamente não-correlacionados entre si, mas a correlação deve ser baixa e convergir para zero à medida que \\(n\\) cresce para infinito. Se estamos supondo que o erro é Gaussiano (Normal), como no modelo de MLE, os resíduos devem também ser normais. Cada uma dessas propriedades nos leva a um diagnóstico ou checagem. 10.2 Modelo no R Para fazer os testes do nosso modelo, vamos fazer um modelo preditivo. Vou utilizar a votação no primeiro turno presidencial de 2018 para prever o voto no segundo turno, no estado de Alagoas. Para tanto, vamos baixar os dados de votação presidencial de 2018 ao nível de seção eleitoral do portal de dados abertos do TSE para o estado de Alagoas (para ter uma base de dados pequena): https://dadosabertos.tse.jus.br/dataset/resultados-2018 library(data.table) # lista o nome do arquivo em csv # unzip(here(&quot;dados&quot;, &quot;votacao_secao_2018_AL.zip&quot;), list = TRUE) #read data1.csv into data frame presid_al18 &lt;- fread(here(&quot;dados&quot;,&quot;votacao_secao_2018_BR.csv&quot;), encoding = &quot;Latin-1&quot;) # filtrando só AL presid_al18 &lt;- presid_al18 %&gt;% filter(SG_UF == &quot;AL&quot;) # modelo voto em Bolsonaro 1t prediz voto no 2t # descobre o que é voto nulo e branco presid_al18 %&gt;% group_by(NM_VOTAVEL) %&gt;% summarise(max(NR_VOTAVEL)) ## # A tibble: 15 × 2 ## NM_VOTAVEL `max(NR_VOTAVEL)` ## &lt;chr&gt; &lt;int&gt; ## 1 ALVARO FERNANDES DIAS 19 ## 2 BENEVENUTO DACIOLO FONSECA DOS SANTOS 51 ## 3 CIRO FERREIRA GOMES 12 ## 4 FERNANDO HADDAD 13 ## 5 GERALDO JOSÉ RODRIGUES ALCKMIN FILHO 45 ## 6 GUILHERME CASTRO BOULOS 50 ## 7 HENRIQUE DE CAMPOS MEIRELLES 15 ## 8 JAIR MESSIAS BOLSONARO 17 ## 9 JOSE MARIA EYMAEL 27 ## 10 JOÃO DIONISIO FILGUEIRA BARRETO AMOEDO 30 ## 11 JOÃO VICENTE FONTELLA GOULART 54 ## 12 MARIA OSMARINA MARINA DA SILVA VAZ DE LIMA 18 ## 13 VERA LUCIA PEREIRA DA SILVA SALGADO 16 ## 14 VOTO BRANCO 95 ## 15 VOTO NULO 96 # 95 e 96 presid_al18_valido &lt;- presid_al18 %&gt;% filter(!NR_VOTAVEL %in% c(95,96)) %&gt;% group_by(NR_SECAO,NR_ZONA, CD_MUNICIPIO, NR_TURNO, NR_VOTAVEL ) %&gt;% summarise(validos = sum(QT_VOTOS)) %&gt;% mutate(bol_bolsonaro = NR_VOTAVEL == 17, validos_bolsonaro = sum(validos*bol_bolsonaro)) %&gt;% summarise(total_validos = sum(validos), validos_bolsonaro = max(validos_bolsonaro), perc_bolsonaro = validos_bolsonaro/total_validos) %&gt;% dplyr::select(-total_validos) %&gt;% pivot_wider(id_cols = c(NR_SECAO, NR_ZONA, CD_MUNICIPIO), names_from = NR_TURNO, values_from = perc_bolsonaro) %&gt;% rename(perc_bolso_turno1 = &#39;1&#39;, perc_bolso_turno2 = &#39;2&#39;) # modelo de regressão reg1 &lt;- lm(perc_bolso_turno2 ~ perc_bolso_turno1, data = presid_al18_valido) summary(reg1) ## ## Call: ## lm(formula = perc_bolso_turno2 ~ perc_bolso_turno1, data = presid_al18_valido) ## ## Residuals: ## Min 1Q Median 3Q Max ## -0.147833 -0.018587 -0.000424 0.018027 0.170229 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 0.0011688 0.0008273 1.413 0.158 ## perc_bolso_turno1 1.1640700 0.0022516 516.986 &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.02885 on 6385 degrees of freedom ## Multiple R-squared: 0.9767, Adjusted R-squared: 0.9767 ## F-statistic: 2.673e+05 on 1 and 6385 DF, p-value: &lt; 2.2e-16 presid_al18_valido %&gt;% ggplot(aes(x=perc_bolso_turno1, y=perc_bolso_turno2)) + geom_point() + geom_abline(slope = coef(reg1)[2] , intercept = coef(reg1)[1], colour = &quot;blue&quot;) 10.2.1 Resíduos contra o preditor Se os resíduos devem ter \\(\\mathbb{E}[\\hat{e}|X=x] = 0\\), isso significa que para cada \\(x_i\\) os resíduos devem ter média zero. Em um gráfico, isso significa que, se eu tiver pontos suficientes na proximidade de cada \\(x_i\\), a dispersão dos resíduos deve ser aleatória, no sentido de não ter padrão claro, o que vai implicar uma reta horizontal cuja média é zero. df &lt;- data.frame(residuos = residuals(reg1), preditor = presid_al18_valido$perc_bolso_turno1) df %&gt;% ggplot(aes(x=preditor, y = residuos)) + geom_point() + geom_smooth(method=&quot;lm&quot;, se=F) Se houver outros preditores, faça a mesma coisa e o gráfico também deve ser uma reta em cima do eixo \\(x\\). 10.2.2 Magnitude dos Resíduos Contra o Preditor Uma vez que \\(\\mathbb{E}[\\hat{e}|X] = 0\\), segue-se que \\(\\mathbb{Var}[\\hat{e}|X] = \\mathbb{E}[\\hat{e^2}|X]\\). Como exercício, verifique que isso é verdade matematicamente (pós) e por simulação (pós e graduação). Abaixo segue uma explicação: Seja \\(A\\) uma v.a. Então, \\(\\mathbb{Var}[A|X] = \\mathbb{E}[(A - \\mathbb{E}[A|X])^2|X]\\) \\[ \\mathbb{Var}[\\hat{e}|X] = \\mathbb{E}[(\\hat{e} - \\mathbb{E}[\\hat{e}|X])^2|X] = \\mathbb{E}[(\\hat{e} - 0)^2|X] = \\mathbb{E}[\\hat{e}^2|X] \\] Portanto, se estamos assumindo homecadisticidade, isto é, que \\(\\mathbb{Var}[\\hat{e}|X] = \\sigma^2\\), podemos checar esta suposição olhando para a esperança condicional do quadrado dos resíduos. E odemos fazer isso plotando o gráfico do quadrado dos resíduos contra o preditor. df &lt;- data.frame(residuos_sq = residuals(reg1)^2, preditor = presid_al18_valido$perc_bolso_turno1) df %&gt;% ggplot(aes(x=preditor, y = residuos_sq)) + geom_point() + geom_smooth(method=&quot;lm&quot;, se=F) A reta deve ser horizontal, e não deveria ter mais pontos acima do que abaixo da reta. A altura da reta deveria ser aproximadamente o EQM. Conjuntos de pontos persistentemente acima ou abaixo da reta são sinais de problema com alguma de nossas hipóteses, ou há heterocedasticidade (a variância muda com o preditor) ou a forma funcional do modelo está errada de algum modo. No meu gráfico, a reta não é exatamente horizontal, mas é “good enough”. Eu não me daria ao trabalhgo de estimar um modelo de regressão de mínimos quadrados ponderados (que não vamos aprender no curso) para lidar com uma variância heterocedástica. Ás vezes quando temos resíduos muito grandes, o quadrado deles fica gigante e o gráfico fica não-informativo (especialmente quando o modelo é problemático). Nesses casos, podemos plotar o valor absoluto dos resíduos, em vez do quadrado. df &lt;- data.frame(residuos_abs = abs(residuals(reg1)), preditor = presid_al18_valido$perc_bolso_turno1) df %&gt;% ggplot(aes(x=preditor, y = residuos_abs)) + geom_point() + geom_smooth(method=&quot;lm&quot;, se=F) 10.2.3 Resíduos com dados Temporais e/ou Espaciais Com frequência nossos dados possuem uma certa ordem, seja temporal e/ou espacial. Em um modelo simples, isso não deveria importar (nossa amostra supostamente é i.i.d, e os erros populacionais são não correlacionados entre si). Se os erros forem correlacionados, podemos usar algo chamado mínimos quadrados generalizados, o que também não iremos cobrir no curso. Então, deveríamos sempre fazer um plot dos resíduos contra o tempo, ou contra o espaço. Aqui, como a ordem é apenas espacial, vamos fazer isso. Podemos fazer um plote dos resíduos contra seção/zona/município, zona/município ou município. Vamos tentar o primeiro, que possui mais granularidade.Vejamos como fica. presid_al18_valido &lt;- presid_al18_valido %&gt;% mutate(id_secao = paste0(NR_SECAO, NR_ZONA , CD_MUNICIPIO)) df &lt;- data.frame(residuos = residuals(reg1), secao = as.numeric(presid_al18_valido$id_secao)) df %&gt;% ggplot(aes(x=secao, y = residuos)) + geom_point() + geom_smooth(method=&quot;lm&quot;, se=F) Uma técnica simples, que é uma versão simplificada de algo mais formal chamado “permutation test”, é plotar os resíduos permutados aleatoriamente contra a data ou espaço (no nosso caso, espaço). presid_al18_valido &lt;- presid_al18_valido %&gt;% mutate(id_secao = paste0(NR_SECAO, NR_ZONA , CD_MUNICIPIO)) df &lt;- data.frame(residuos_s = sample(residuals(reg1)), secao = as.numeric(presid_al18_valido$id_secao)) df %&gt;% ggplot(aes(x=secao, y = residuos_s)) + geom_point() + geom_smooth(method=&quot;lm&quot;, se=F) Rodando o código algumas vezes, podemos verificar que o “jeitão” dele é muito parecido com o nosso gráfico na ordem original, o que sugere que está tudo bem com nossos resíduos com relação à correlação espacial deles. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
